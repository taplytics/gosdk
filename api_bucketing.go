/*
 * Taplytics Universal API
 *
 * The Taplytics Universal API is an API to quickly use Taplytics features and functionality at edge. This API allows the utilization of the Taplytics experimentation  functionality anywhere in the stack, both client- and server-side.  Each call to the Universal API requires two main parameters: token and user_id. - token is unique to each Taplytics project and can be found under Settings -> Project Settings -> Taplytics SDK Key - user_id is your custom defined user ID.  To be able to utilize the Universal API, please ensure that your Taplytics project is setup for usage. You may contact your Account Manager or support@taplytics.com for any questions.
 *
 * API version: 1.1
 * Contact: support@taplytics.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gosdk

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// BucketingApiService BucketingApi service
type BucketingApiService service

type ApiBucketingGetRequest struct {
	ctx        _context.Context
	ApiService *BucketingApiService
	token      *string
	userId     *string
	attributes *UserAttributes
	customData *map[string]interface{}
	verbose    *bool
}

func (r ApiBucketingGetRequest) Token(token string) ApiBucketingGetRequest {
	r.token = &token
	return r
}
func (r ApiBucketingGetRequest) UserId(userId string) ApiBucketingGetRequest {
	r.userId = &userId
	return r
}
func (r ApiBucketingGetRequest) Attributes(attributes UserAttributes) ApiBucketingGetRequest {
	r.attributes = &attributes
	return r
}
func (r ApiBucketingGetRequest) CustomData(customData map[string]interface{}) ApiBucketingGetRequest {
	r.customData = &customData
	return r
}
func (r ApiBucketingGetRequest) Verbose(verbose bool) ApiBucketingGetRequest {
	r.verbose = &verbose
	return r
}

func (r ApiBucketingGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BucketingGetExecute(r)
}

/*
 * BucketingGet Get Experiments and Variations for the user.
 * Returns a key/value pairing of all experiments that the user has been segmented into, as well as the variation the users are assigned.  If there are no experiments currently being delivered to the user, an empty response will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBucketingGetRequest
 */
func (a *BucketingApiService) BucketingGet(ctx _context.Context) ApiBucketingGetRequest {
	return ApiBucketingGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *BucketingApiService) BucketingGetExecute(r ApiBucketingGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketingApiService.BucketingGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucketing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.token == nil {
		return nil, reportError("token is required and must be specified")
	}
	if r.userId == nil {
		return nil, reportError("userId is required and must be specified")
	}
	if r.attributes == nil {
		return nil, reportError("attributes is required and must be specified")
	}
	if r.customData == nil {
		return nil, reportError("customData is required and must be specified")
	}

	localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.verbose != nil {
		localVarQueryParams.Add("verbose", parameterToString(*r.verbose, ""))
	}
	localVarQueryParams.Add("attributes", parameterToString(*r.attributes, ""))
	localVarQueryParams.Add("customData", parameterToString(*r.customData, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBucketingPostRequest struct {
	ctx                          _context.Context
	ApiService                   *BucketingApiService
	token                        *string
	userId                       *string
	verbose                      *bool
	userAttributesWithCustomData *UserAttributesWithCustomData
}

func (r ApiBucketingPostRequest) Token(token string) ApiBucketingPostRequest {
	r.token = &token
	return r
}
func (r ApiBucketingPostRequest) UserId(userId string) ApiBucketingPostRequest {
	r.userId = &userId
	return r
}
func (r ApiBucketingPostRequest) Verbose(verbose bool) ApiBucketingPostRequest {
	r.verbose = &verbose
	return r
}
func (r ApiBucketingPostRequest) UserAttributesWithCustomData(userAttributesWithCustomData UserAttributesWithCustomData) ApiBucketingPostRequest {
	r.userAttributesWithCustomData = &userAttributesWithCustomData
	return r
}

func (r ApiBucketingPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BucketingPostExecute(r)
}

/*
 * BucketingPost Get Experiments and Variations for the user.
 * Returns a key/value pairing of all experiments that the user has been segmented into, as well as the variation the users are assigned.  If there are no experiments currently being delivered to the user, an empty response will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBucketingPostRequest
 */
func (a *BucketingApiService) BucketingPost(ctx _context.Context) ApiBucketingPostRequest {
	return ApiBucketingPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *BucketingApiService) BucketingPostExecute(r ApiBucketingPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketingApiService.BucketingPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucketing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.token == nil {
		return nil, reportError("token is required and must be specified")
	}
	if r.userId == nil {
		return nil, reportError("userId is required and must be specified")
	}

	localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	if r.verbose != nil {
		localVarQueryParams.Add("verbose", parameterToString(*r.verbose, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/jason"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userAttributesWithCustomData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
